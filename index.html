<!doctype html>
<html>

<head>
	<meta charset="UTF-8" />
	<title></title>

	<script src="jquery-3.3.1.min.js"></script>

	<style>
		@font-face {
			font-family: 'emojii';
			src: url('TwitterColorEmoji-SVGinOT.ttf');
		}


		* {
			font-family: emojii;
		}

		body {
			background-image: url('bosch-logo-2.png');
			background-repeat: no-repeat;
			background-attachment: fixed;
			background-position: center;
			background-size: contain;
		}

		#container {
			position: absolute;
			margin: 0 auto;

			top: 50%;
			left: 50%;
			-ms-transform: translate(-50%, -50%);
			transform: translate(-50%, -50%);
		}

		body {
			padding: 0;
			margin: 0;
			width: 100%;
			height: 100%;
		}
		#ownLogo {
			position: absolute;
			right: 0px;
			bottom: 0px;
			font-size: 50px;
		}
		
		.slider {
			width: 100%;
		}
	</style>


</head>

<body>
	<div id="container">
		<div>
			<code id="currentTime"></code>
		</div>
		<div>
			<input id="filterInput" onkeyup="filter()">
		</div>
		<canvas id="myCanvas" width="1000" height="600" style="border:1px solid #000000;"></canvas>
		<input type="range" class="slider" id="slider" onmousedown="sliderChangeEvent()" onmouseup="sliderChangeEndEvent()" onchange="sliderChangeMoveEvent()">
		<button id="pauseButton" onclick="pause()" disabled>Pause</button>
		<button id="playButton" onclick="play()">Play</button>
		<input id="gotoInput" type="text">
		<button id="gotoButton" onclick="goToTime()">Go</button>
	</div>

	<div id="ownLogo"><font color="brown">üçû</font><font color="black">‚ûïÔ∏è</font><font color="red">üçÖ</font></div>

</body>
<script>
	var scanData;
	var c = document.getElementById("myCanvas");
	var ctx = c.getContext("2d");
	var items = [];
	var currentTime;
	var tickRate = 1000/60;
	var timeBetweenTicks = tickRate * 10;
	var timer;
	var filterType;
	
	var checkpoints = [];
	var maxX = -10000.0, minX = 10000.0, maxY = -10000.0, minY = 10000.0, maxZ = -10000.0, minZ = 10000.0;
	var minTime = 15393024303810, maxTime = 0;

	$.ajax({
		method: "GET",
		url: "scans.json",
		dataType: "text"
	}).done(function (data) {
		scanData = JSON.parse(data);

		var maxX = -10000.0, minX = 10000.0, maxY = -10000.0, minY = 10000.0, maxZ = -10000.0, minZ = 10000.0;
		minTime = 15393024303810, maxTime = 0;


		for (i = 0; i < scanData.length; i++) {

			//MinMax calculations
			if (scanData[i].location[0] > maxX) {
				maxX = scanData[i].location[0];
			}
			if (scanData[i].location[0] < minX) {
				minX = scanData[i].location[0];
			}

			if (scanData[i].location[1] > maxY) {
				maxY = scanData[i].location[1];
			}
			if (scanData[i].location[1] < minY) {
				minY = scanData[i].location[1];
			}

			if (scanData[i].location[2] > maxZ) {
				maxZ = scanData[i].location[2];
			}
			if (scanData[i].location[2] < minZ) {
				minZ = scanData[i].location[2];
			}

			if (scanData[i].timestamp > maxTime) {
				maxTime = scanData[i].timestamp;
			}
			if (scanData[i].timestamp < minTime) {
				minTime = scanData[i].timestamp;
			}

			//Location build
			var loc = {
				x: scanData[i].location[0],
				y: scanData[i].location[1],
				z: scanData[i].location[2]
			};

			var currentCheckpoint = checkpointFind(checkpoints, loc);
			if (currentCheckpoint == null) {
				currentCheckpoint = checkpointAdd(checkpoints, loc);
			}

			if (items[scanData[i].id] == undefined) {
				items[scanData[i].id] = {
					id: scanData[i].id,
					name: scanData[i].name,
					type: scanData[i].type,
					locations: [{timestamp: scanData[i].timestamp, checkpoint: currentCheckpoint}]
				};
			} else {
				var lastLocation = items[scanData[i].id].locations[items[scanData[i].id].locations.length - 1];
				items[scanData[i].id].locations.push({timestamp: scanData[i].timestamp, checkpoint: currentCheckpoint});
				var newLocation = items[scanData[i].id].locations[items[scanData[i].id].locations.length - 1];
				
				if (lastLocation != undefined) {
					if (!lastLocation.checkpoint.nextCPs.includes(newLocation.checkpoint)) {
						lastLocation.checkpoint.nextCPs.push(newLocation.checkpoint);
					}
					
					if (!newLocation.checkpoint.previousCPs.includes(lastLocation.checkpoint)) {
						newLocation.checkpoint.previousCPs.push(lastLocation.checkpoint);
					}
				}
			}

		};

		checkpoints.sort(function (a, b) {
			if (a.x != b.x) {
				return b.x - a.x;
			} else if (a.y != b.y) {
				return b.y - a.y;
			} else {
				return b.z - a.z;
			}
		});

		console.log("MaxX:" + maxX);
		console.log("MinX:" + minX);
		console.log("MaxY:" + maxY);
		console.log("MinY:" + minY);
		console.log("MaxZ:" + maxZ);
		console.log("MinZ:" + minZ);
		console.log("MaxTime:" + maxTime);
		console.log("MinTime:" + minTime);
		console.log("Timediff:" + (maxTime - minTime));

		
		$("#slider").attr("min",minTime).attr("max",maxTime);
		currentTime = minTime;
		clearCanvas();
		drawCanvas();
	});
	
	
	function getEmoji(type) {
		var emojistring = "";

		switch (type) {
			case "air+freshener": emojistring = "üå´Ô∏è"; break;
			case "apple": emojistring = "üçé"; break;
			case "bag": emojistring = "üëú"; break;
			case "balloon": emojistring = "üéà"; break;
			case "bananas": emojistring = "üçå"; break;
			case "beef": emojistring = "ü•©"; break;
			case "blanket": emojistring = "üëò"; break;
			case "blouse": emojistring = "üëö"; break;
			case "book": emojistring = "üìó"; break;
			case "bookmark": emojistring = "üîñ"; break;
			case "boom+box": emojistring = "üìª"; break;
			case "bottle": emojistring = "üçº"; break;
			case "bottle+cap": emojistring = "üç∂"; break;
			case "bow": emojistring = "üèπ"; break;
			case "bowl": emojistring = "ü•£"; break;
			case "box": emojistring = "üßÉ"; break;
			case "bracelet": emojistring = "ü¶æ"; break;
			case "bread": emojistring = "üçû"; break;
			case "brocolli": emojistring = "ü•í"; break;
			case "buckel": emojistring = "üê™"; break;
			case "button": emojistring = "üîò"; break;
			case "camera": emojistring = "üì∑"; break;
			case "candle": emojistring = "üïØÔ∏è"; break;
			case "candy+wrapper": emojistring = "üç¨"; break;
			case "canvas": emojistring = "üìã"; break;
			case "carrots": emojistring = "ü•ï"; break;
			case "cat": emojistring = "üêà"; break;
			case "CD": emojistring = "üíø"; break;
			case "cell+phone": emojistring = "üì±"; break;
			case "chalk": emojistring = "‚úçÔ∏è"; break;
			case "chapter+book": emojistring = "üïÖ"; break;
			case "charger": emojistring = "üîã"; break;
			case "checkbook": emojistring = "üõÇ"; break;
			case "chocolate": emojistring = "üç´"; break;
			case "cinder+block": emojistring = "üî•"; break;
			case "clamp": emojistring = "üóúÔ∏è"; break;
			case "clay+pot": emojistring = "üß±"; break;
			case "clock": emojistring = "‚è∞"; break;
			case "clothes": emojistring = "üëñ"; break;
			case "coasters": emojistring = "üé¢"; break;
			case "computer": emojistring = "üíª"; break;
			case "conditioner": emojistring = "üå±"; break;
			case "controller": emojistring = "üéÆ"; break;
			case "cookie+jar": emojistring = "ü•†"; break;
			case "cork": emojistring = "üçæ"; break;
			case "credit+card": emojistring = "üí≥"; break;
			case "cup": emojistring = "ü•§"; break;
			case "deodorant": emojistring = "üöÅ"; break;
			case "doll": emojistring = "üéé"; break;
			case "drill+press": emojistring = "üö¥"; break;
			case "eraser": emojistring = "‚úè"; break;
			case "eye+liner": emojistring = "üëÄ"; break;
			case "face+wash": emojistring = "ü•µ"; break;
			case "fake+flowers": emojistring = "üåπ"; break;
			case "flag": emojistring = "üè≥Ô∏è"; break;
			case "floor": emojistring = "üßé"; break;
			case "flowers": emojistring = "üíê"; break;
			case "food": emojistring = "ü•´"; break;
			case "fork": emojistring = "üç¥"; break;
			case "fridge": emojistring = "‚ùÑÔ∏è"; break;
			case "glass": emojistring = "üç∏"; break;
			case "glasses": emojistring = "üëì"; break;
			case "glow+stick": emojistring = "üåü"; break;
			case "greeting+card": emojistring = "ü§ù"; break;
			case "grid+paper": emojistring = "üèÅ"; break;
			case "hair+brush": emojistring = "üë±‚Äç"; break;
			case "hair+tie": emojistring = "üëî"; break;
			case "hanger": emojistring = "üìî"; break;
			case "headphones": emojistring = "üéß"; break;
			case "helmet": emojistring = "‚õëÔ∏è"; break;
			case "ice+cube+tray": emojistring = "üßä"; break;
			case "ipod": emojistring = "üíä"; break;
			case "keyboard": emojistring = "‚å®Ô∏è"; break;
			case "key+chain": emojistring = "üîê"; break;
			case "keys": emojistring = "üîë"; break;
			case "knife": emojistring = "üî™"; break;
			case "lace": emojistring = "üñ≤Ô∏è"; break;
			case "lamp": emojistring = "üí°"; break;
			case "lamp+shade": emojistring = "ü™î"; break;
			case "leg+warmers": emojistring = "ü¶µ"; break;
			case "lip+gloss": emojistring = "üíÑ"; break;
			case "lotion": emojistring = "üß¥"; break;
			case "magnet": emojistring = "üß≤"; break;
			case "milk": emojistring = "ü•õ"; break;
			case "mirror": emojistring = "üöç"; break;
			case "money": emojistring = "üí∏"; break;
			case "monitor": emojistring = "üñ•Ô∏è"; break;
			case "mop": emojistring = "üßΩ"; break;
			case "mouse+pad": emojistring = "üñ±Ô∏è"; break;
			case "mp3+player": emojistring = "üíΩ"; break;
			case "nail+clippers": emojistring = "üíÖ"; break;
			case "nail+file": emojistring = "üìÅ"; break;
			case "needle": emojistring = "üíâ"; break;
			case "newspaper": emojistring = "üì∞"; break;
			case "outlet": emojistring = "‚ôÄÔ∏è"; break;
			case "packing+peanuts": emojistring = "ü•ú"; break;
			case "paint+brush": emojistring = "üñåÔ∏è"; break;
			case "pants": emojistring = "üßê"; break;
			case "paper": emojistring = "üßª"; break;
			case "pen": emojistring = "üñãÔ∏è"; break;
			case "pencil": emojistring = "‚úèÔ∏è"; break;
			case "perfume": emojistring = "üö¨"; break;
			case "phone": emojistring = "‚òéÔ∏è"; break;
			case "photo+album": emojistring = "ü§≥"; break;
			case "picture+frame": emojistring = "üñºÔ∏è"; break;
			case "pillow": emojistring = "üõèÔ∏è"; break;
			case "plastic+fork": emojistring = "üéç"; break;
			case "plate": emojistring = "üçΩÔ∏è"; break;
			case "playing+card": emojistring = "üÉè"; break;
			case "pool+stick": emojistring = "üé±"; break;
			case "puddle": emojistring = "üèä"; break;
			case "purse": emojistring = "üëõ"; break;
			case "radio": emojistring = "üéôÔ∏è"; break;
			case "remote": emojistring = "üìè"; break;
			case "ring": emojistring = "üíç"; break;
			case "rubber+band": emojistring = "üí∂"; break;
			case "rubber+duck": emojistring = "ü¶Ü"; break;
			case "rug": emojistring = "ü§´"; break;
			case "rusty+nail": emojistring = "üî®"; break;
			case "sailboat": emojistring = "‚õµ"; break;
			case "sandal": emojistring = "üë°"; break;
			case "sand+paper": emojistring = "‚è≥"; break;
			case "scotch+tape": emojistring = "ü•É"; break;
			case "screw": emojistring = "üî©"; break;
			case "seat+belt": emojistring = "ü•ã"; break;
			case "shampoo": emojistring = "üß¥"; break;
			case "sharpie": emojistring = "ü•ß"; break;
			case "shawl": emojistring = "‚òÇÔ∏è"; break;
			case "shirt": emojistring = "üéΩ"; break;
			case "shoe+lace": emojistring = "üëû"; break;
			case "shoes": emojistring = "üëü"; break;
			case "shovel": emojistring = "ü•Ñ"; break;
			case "sidewalk": emojistring = "üöì"; break;
			case "sketch+pad": emojistring = "üìî"; break;
			case "slipper": emojistring = "ü•ø"; break;
			case "soap": emojistring = "üßº"; break;
			case "socks": emojistring = "üß¶"; break;
			case "soda+can": emojistring = "ü•§"; break;
			case "sofa": emojistring = "üõãÔ∏è"; break;
			case "soy+sauce+packet": emojistring = "üç¢"; break;
			case "speakers": emojistring = "üîà"; break;
			case "sponge": emojistring = "üßΩ"; break;
			case "spoon": emojistring = "ü•¢"; break;
			case "spring": emojistring = "‚ô®Ô∏è"; break;
			case "sticky+note": emojistring = "üí¥"; break;
			case "stockings": emojistring = "üìà"; break;
			case "stop+sign": emojistring = "üõë"; break;
			case "street+lights": emojistring = "üö¶"; break;
			case "sun+glasses": emojistring = "üï∂Ô∏è"; break;
			case "table": emojistring = "üìã"; break;
			case "teddies": emojistring = "üß∏"; break;
			case "thermometer": emojistring = "üå°Ô∏è"; break;
			case "thermostat": emojistring = "ü§í"; break;
			case "thread": emojistring = "üßµ"; break;
			case "tire+swing": emojistring = "üò´"; break;
			case "tissue+box": emojistring = "ü§ß"; break;
			case "toe+ring": emojistring = "üë£"; break;
			case "toilet": emojistring = "üöΩ"; break;
			case "tomato": emojistring = "üçÖ"; break;
			case "toothbrush": emojistring = "ü¶∑"; break;
			case "toothpaste": emojistring = "ü§™"; break;
			case "tooth+picks": emojistring = "üóùÔ∏è"; break;
			case "towel": emojistring = "üßª"; break;
			case "tree": emojistring = "üå≥"; break;
			case "truck": emojistring = "üöö"; break;
			case "tv": emojistring = "üì∫"; break;
			case "twezzers": emojistring = "üí¢"; break;
			case "twister": emojistring = "üåÄ"; break;
			case "USB+drive": emojistring = "‚õìÔ∏è"; break;
			case "vase": emojistring = "‚ö±Ô∏è"; break;
			case "video+games": emojistring = "üéÆ"; break;
			case "wagon": emojistring = "üöÉ"; break;
			case "wallet": emojistring = "üëõ"; break;
			case "watch": emojistring = "‚åö"; break;
			case "water+bottle": emojistring = "üåä"; break;
			case "white+out": emojistring = "‚¨ú"; break;
			case "zipper": emojistring = "ü§ê"; break; default: emojistring = "üçû"; break;
		}

		return emojistring;
	}

	function drawType(x, y, z, type) {
		// The size of the emoji is set with the font
		ctx.font = '20px serif'
		ctx.textAlign = "center";
		ctx.textBaseline = "middle";

		ctx.fillText(getEmoji(type), x, y);
	}

	function checkpointFind(container, loc) {
		var checkpointCount = 0;
		while (checkpointCount < container.length && !(container[checkpointCount].x == loc.x &&
													 container[checkpointCount].y == loc.y &&
													 container[checkpointCount].z == loc.z)) {
			checkpointCount++;
		}
		
		if (checkpointCount < container.length) {
			return container[checkpointCount];
		} else {
			return null;
		}
	}

	function checkpointAdd(container, loc) {
		container.push({
			id: container.length,
			x:loc.x,
			y:loc.y,
			z:loc.z,
			isStart: false,
			isEnd: false,
			nextCPs: [],
			previousCPs: [],
		});
		
		return container[container.length - 1];
	}
	
	function circleRadius(cp) {
		return (-cp.z / 2) + 5
	}

	function circlePos(cp) {
		return {
			x: cp.x * 22 - 200,
			y: cp.y * 20 - (cp.z * 10),
			r: circleRadius(cp)
		}
	}

	
	function circlePosBetween(from, to, percent) {
		percent = Math.min(Math.max(percent, 0), 100);
		
		let fromCP = circlePos(from);
		let toCP = circlePos(to);
		return {
			x: fromCP.x + (toCP.x - fromCP.x) * percent / 100,
			y: fromCP.y + (toCP.y - fromCP.y) * percent / 100,
			r: fromCP.r + (toCP.r - fromCP.r) * percent / 100
		}
	}

	function drawCheckpoints() {
				for (i = 0; i < checkpoints.length; i++) {
					for (j = 0; j < checkpoints[i].nextCPs.length; j++) {
						let fromCP = circlePos(checkpoints[i]);
						let toCP = circlePos(checkpoints[i].nextCPs[j]);
						let dirX = toCP.x - fromCP.x;
						let dirY = toCP.y - fromCP.y;
						let norm = Math.sqrt(dirX * dirX + dirY * dirY);
						dirX /= norm;
						dirY /= norm;

						ctx.beginPath();
						ctx.moveTo(fromCP.x + dirY * fromCP.r, fromCP.y - dirX * fromCP.r);
						ctx.lineTo(toCP.x + dirY * toCP.r, toCP.y - dirX * toCP.r);
						ctx.strokeStyle = "black";
						ctx.stroke();
						
						ctx.beginPath();
						ctx.moveTo(fromCP.x - dirY * fromCP.r, fromCP.y + dirX * fromCP.r);
						ctx.lineTo(toCP.x - dirY * toCP.r, toCP.y + dirX * toCP.r);
						ctx.strokeStyle = "black";
						ctx.stroke();
					}
				}
			
				for (i = 0; i < checkpoints.length; i++) {
					ctx.beginPath();
					let cp = circlePos(checkpoints[i]);

					ctx.arc(cp.x, cp.y, cp.r, 0, 2 * Math.PI);
					ctx.strokeStyle = "green";
					ctx.stroke();
				}
 			}

	function pause(){
		$("#pauseButton").attr("disabled",true);
		$("#playButton").attr("disabled",false);

		clearInterval(timer);
		timer = undefined;
	}

	function play(){
		$("#pauseButton").attr("disabled",false);
		$("#playButton").attr("disabled",true);

		timer = setInterval(function(){
			if(currentTime < maxTime){
				currentTime += timeBetweenTicks;
				if(currentTime >= maxTime){
					currentTime = maxTime;
				}
				clearCanvas();
				drawCanvas();
				document.getElementById('slider').value = currentTime +"";
			} else {
				pause();
			}
			console.info(currentTime)
		}, tickRate)
	}

	function clearCanvas(){
		ctx.setTransform(1, 0, 0, 1, 0, 0);
		ctx.clearRect(0, 0, c.width, c.height);
		document.getElementById("currentTime").innerText = Math.round(currentTime);
	}

	function drawCanvas(){
		drawCheckpoints();
		console.log("hehe");
		
		for (var key in items) {
			var previousCP, nextCP;
			
			var j = 0;
			
			while (j < items[key].locations.length - 1 && !(items[key].locations[j].timestamp <= currentTime && items[key].locations[j + 1].timestamp > currentTime)) {
				j++;
	}
			
			if (j < items[key].locations.length - 1) {
				
				previousCP = items[key].locations[j].checkpoint;
				nextCP = items[key].locations[j + 1].checkpoint;
				
				var timeScale = (currentTime - items[key].locations[j].timestamp) / (items[key].locations[j + 1].timestamp - items[key].locations[j].timestamp);
				var x = (nextCP.x - previousCP.x) * timeScale + previousCP.x;
				var y = (nextCP.y - previousCP.y) * timeScale + previousCP.y;
				
				console.log(x + " " + y);
				
				
				var hehe = circlePosBetween(previousCP, nextCP, timeScale * 100);
				/*ctx.beginPath();

				ctx.arc(hehe.x, hehe.y, hehe.r, 0, 2 * Math.PI);
				ctx.strokeStyle = "green";
				ctx.stroke();*/
				if(filterType == undefined ||  filterType != "" && items[key].type.indexOf(filterType) != -1){
					drawType(hehe.x, hehe.y, 0, items[key].type);
				}
			}
		}
	}

	function filter(){
		var filterInput = document.getElementById("filterInput").value;
		if(filterInput != "" && filterInput != undefined){
			filterType = filterInput;
		} else {
			filterType = undefined;
		}
		clearCanvas();
		drawCanvas();
	}

	function goToTime(){
		var time = document.getElementById("gotoInput").value;
		if(time != undefined && time != "" && (parseInt(time) >= minTime || parseInt(time) <= maxTime)){
			document.getElementById('slider').value = time;
			sliderChangeMoveEvent();
			pause();
		}
	}

	var wasTimer;
	function sliderChangeEvent() {
		wasTimer = timer;
		if (wasTimer)
			pause();
	}

	function sliderChangeMoveEvent() {
		let value = document.getElementById('slider').value;
		currentTime = parseInt(value);
		
		clearCanvas();
		drawCanvas();
	}

	function sliderChangeEndEvent() {
		if (wasTimer)
			play();
	}
			//function textList()

</script>

</html>
